# Понимание JVM.

В моем понимании исходя из информации из вебинара и презентации все происходит так:

1. Первым делом происходит загрузка класса JvmComprehension: сначала Bootstrap Classloader загружает классы Object, Integer, System и далее Application Classloader загружает JvmComprehension.
2. Далее происходит подготовка классов к выполнению: код проверяется на корректность, проверяется загруженность необходимых классов и происходит инициализация.
3. Результат предыдущих действий (все загруженные классы) будет загружен в Metaspace.
4. В Stack создается фрейм main. Здесь создаются:\
	а) переменная int i = 1;\
	б) создается переменная o, которая является ссылкой на объект Object, созданный в Heap;\
	в) создается переменная ii, которая является ссылкой на объект Integer, который равен 2, созданный в Heap;
5. Далее происходит вызов метода и, соответственно, в Stack создается новый фрейм printAll. В нем создаются:\
	а) новая ссылка o на Object в Heap;\
	б) новая ссылка ii на Integer в Heap;\
	в) ссылка uselessVar на объект Integer, равный 700, созданный в Heap;
6. Далее вызывается метод toString и в Stack создается фрейм toString, который использует еще одну ссылку o на объект Object в Heap, в результате работы которого мы получаем новый объект типа String в Heap.
7. Происходит вызов метода println и в Stack создается фрейм println.\
	а) в нем мы используем объект типа String из Heap, полученный в результате работы предыдущего фрейма;\
	б) производим конкатенацию  вышеуказанного объекта с переменной i из фрейма main и объектом Integer по ссылке ii;\
	в) результат конкатенации распечатывается в консоли.
8. Вызывается еще один метод println и создается еще один фрейм в Stack - здесь мы создаем объект типа String со значением "finished" в Heap и выводим его в консоль.
9. Сборщик мусора - учитывая то, что данный процесс происходит автоматически и один из созданных объектов в Heap не используется (объект типа Integer со значением 700), то при первой же обходе он будет удален как недостижимый.


# Исследование JVM через VisualVM (задача со звездочкой *).

По заданию у нас есть программа, которая с определенным интервалом подгружает нам классы определенных пакетов, а затем через какой-то интервал создает нам определенное количество объектов-списков. В результате работы данной программы мы можем наблюдать что происходит в Metaspace и Heap с помощью VisualVM.
###Как я интерпретирую увиденное:
![](https://disk.yandex.ru/i/rJOMhO4FdHZ_Ww)
![](https://disk.yandex.ru/i/b00LIR2nY24tTw)
![](https://disk.yandex.ru/i/y5LzmTw3994aZg)

1. Изначально у нас работает Classloader и подгружает системные классы и объекты (Heap тоже немного используется).
2. Далее предлагаю обратиться к графику Metaspace.
   ![](https://disk.yandex.ru/i/b00LIR2nY24tTw) \
Тут начинают загружаться классы из пакетов и Metaspace начинает активно использоваться и автоматически увеличиваться в соответствии с нехваткой размера. Отрезки 0-1, 2-3 и 6-7 хорошо нам это визуально демонстрируют:\
	а) 0-1 - загрузка 529 классов из vertex.io;\
    б) 2-3 - загрузка 2117 классов из io.netty;\
    в) далее при подгрузке 869 классов из org.springframework размер Metaspace не меняется, а делает это лишь в начале создания первого создания огромного количества объектов. К сожалению не могу объяснить данный факт и хотелось бы услышать вразумительное объяснение.
 3. А теперь пора смотреть на Heap:
	![](https://disk.yandex.ru/i/y5LzmTw3994aZg) \
	а) из графика видно, что при загрузке классов создаеются объекты (скорее всего экземпляры класса), которые потихоньку заполняют Heap. Об этом нам говорят отрезки 0-1, 2-3 и 5-6.\
	б) на отрезке 3-4 мы можем наблюдать работу сборщика мусора, который освобождает Heap от неиспользуемых объектов.\
	в) отрезок 7-8 отображает нам первое из созданий множества объектов и тут мы видим резкое возрастание использования Heap, но так как мы не сильно приблизились к её максимальному размеру, то максимальный размер Heap вырос несущественно. Подозреваю, что на данном этапе, опять же, отработал сборщик мусора, поэтому увеличение использования объема Heap не столь велико, как в последующие разы. \
	г) при повторном создании множества объектов (отрезок 9-10) у нас происходит резкая нагрузка на Heap, приближение к ее максимальному значению, и она автоматически увеличивается до такой степени, что даже третье создание (отрезок 11-12) никак не влияет на максимальный размер. \
	д) нужно также отметить, что использование Metaspace в данном случае остаётся неизменным.